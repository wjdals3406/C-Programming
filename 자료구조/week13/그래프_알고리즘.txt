<신장 트리>
- 그래프 내의 모든 정점을 포함하는 트리(그래프 내의 모든 정점 탐색)
- n개의 정점을 가지는 트리는 n-1개의 간선을 가짐
- 하나의 그래프에서 신장 트리 여러 개 존재할 수 있음
- 사이클 포함X

<최소비용 신장트리>
- 간선의 가중치 합이 최소인 신장트리
다음을 만족해야함
- 가장 적은 수의 간선과 비용(가중치)로 연결됨
-> n개의 정점과 n-1개의 간선
- 사이클이 없어야 함

<크루스칼>
- 탐욕적인 방법
- 최적의 해답 임이 증명됨
- 탐욕적인 방법은 항상 최적의 해답을 주는지 검증 필요
- 간선을 이용함(가중치 값이 가장 작은 순서대로 탐색)
- 간선 기준으로 오름차순 정렬

선택한 노드가 같은 그래프 집합 (정점의 루트 노드가 같음)
= 같은 집합에 속해있음 -> 선택하면 안됨

Q) 크루스칼을 이용하여 신장트리 찾아라

크루스칼 -> 어떤 정렬 알고리즘을 쓰느냐에 따라 시간복잡도가 달라짐
퀵 정렬 시간복잡도 : O(eloge)


<Prim 알고리즘>
- 시작 정점에서부터 신장 트리 집합을 단계적으로 확장
- 시작 정점 정해야함


<다익스트라>
- 하나의 시작 정점에서 다른 정점까지의 최단경로 계산
<플로이드>
- 모든 정점에서 다른 모든 정점까지의 최단 경로 계산

<위상 정렬>
방향 그래프에서 간선 <u,v>가 있다면 정점 u는 정점 v를 선행함
선행관계 위배하지 않으면서 모든 정점 나열하는 것

시작점 : 진입차수가 없는 곳
종료점 : 진출차수가 없는 곳
모든 정점이 선행 정점을 가짐 = 사이클 존재 ->  위상 정렬 불가

우선순위 큐 : 우선순위를 가진 항목 저장
find함수 = peek함수
delete : 우선순위가 가장 높은/작은 요소 제거
최소 우선순위 큐
최대 우선순위 큐

배열/ 연결리스트/ 히프(heap)을 이용해 구현

정렬 X 노드 삽입 시간복잡도 : O(1) -> 그냥 뒤에 붙이면 됨 => 교재에서 다시 한번 확인하기
정렬 O 노드 삽입 시간복잡도 : O(n) 

표현 방법           삽입    삭제
순서X배열           O(1)    O(n)
순서X연결리스트     O(1)    O(n)
정렬된 배열         O(n)    O(1)
정렬된 연결리스트   O(n)    O(1)
히프                O(logn)    O(logn)

<히프>
- 완전 이진트리
- 중복값 허용(트리는 중복값 허용하지만 이진 탐색 트리는 중복값 허용하지 않았음)
[최대 우선순위 큐]
- 부모노드의 값 >= 자식노드의 값
- 왼쪽트리가 꼭 오른쪽트리보다 작아야 하는 것 아님
- 그냥 수평기준으로 위에 있는 노드값이 밑에 있는 노드의 값보다 커야함
- root = 가장 큰 값
- 최대 힙 = 업힙

[최소 우선순위 큐] 
- 최소 우선순위 큐의 반대
- 부모노드의 값 <= 자식노드의 값)
- root = 가장 작은 값

히프의 삽입,삭제 시간 복잡도 : O(logn)
왼쪽 자식 인덱스 = 부모 인덱스 *  2
오른쪽 자식 인덱스 = 부모 인덱스 * 2 + 1
부모 인덱스 = 자식인덱스/2

[노드 삭제]
- root 노드 삭제
- 말단 노드를 root 자리로 옮김
- switch해가면서 본인 자리 찾아감

힙트리 pop -> 내림차순 정렬
힙트리 -> 코드 시험에 안냄

삽입, 삭제할때 위아래 값만 비교함
최대 : 힙의 높이만큼 비교
삽입, 삭제 시간복잡도 : O(logn)
정렬 시간복잡도 : nlog(n) -> 한개 삭제하는데 logn만큼 소요되니까 n개의 요소 삭제하면 nlogn
힙정렬 -> 효율성 높음

