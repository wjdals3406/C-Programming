<그래프>
: 노드가 연결되어 있음
- 트리는 부모하고만 연결되어 있음
- 모든 노드가 연결될 필요는 없음

그래프 G : (V,E)로 표시
V는 vertices로, 노드를 의미
E는 edge로 링크(link)라고도 불림 / 정점과 정점의 연결 집합
V(G) = {0,1,2,3} 노드 집합
E(G) = {(0,1), (0,2)} 0이라는 정점과 1이라는 정점이 연결됨

방향 그래프는 {<0,1>, <0,2>} 이렇게 표시함

가중치 그래프 = 네트워크
- 간선이 어떤 값을 가지는 것
- 간선에 비용이나 가중치가 할당된 그래프

<무방향 그래프>
인접 정점 : 하나의 정점에서 간선에 의해 직접 연결된 정점
차수(degree) : 하나의 정점에 연결된 다른 정점의 수(인접 정점의 수)
간선수 * 2 = 차수합

<방향 그래프>
집입 차수 : 외부에서 오는 간선의 수
진출 차수 : 외부로 향하는 간선의 수
진입차수 합 = 진출차수합 = 간선합

그래프의 경로
나열된 정점들 사이에 반드시 간선이 있어야 함
start 정점과 end 정점이 같다 -> 사이클

모든 정점이 다른 모든 정점과 연결되어 있는 것
: 연결 그래프 <-> 비연결 그래프

완전 그래프 : 모든 정점이 연결되어 있는 그래프
n=4 -> 간선의 수 : (4x3)/2 = 6개

<인접행렬 방식>
그래프가 존재 -> M[i][j] = 1
그래프 존재x -> M[i][j] = 0
무방향 그래프 : 대칭구조
방향 그래프 : 대칭구조X
0이라는 정점이 가지는 차수를 계산하고 싶을 때 : 반복문으로 행의 합을 구함
간선의 수 구하기 : 간선의 수를 다 더하고 2로 나누기
특정 간선 삽입하기 : i,j번째 값을 1로 바꾸기
특정 간선 삭제하기 : i,j번째 값을 0으로 바꾸기

<인접리스트 방식>
- 링크로 표현
- 차수 : 연결리스트가 가지고 있는 노드 개수 구하기
정점의 연결된 정점수 구하기
간선 삽입
-> 삽입 위치는 자유이지만 insert_first가 빠름

<그래프 탐색>
하나의 정점으로부터 모든 정점을 방문하는 것
1) 깊이 우선 탐색(dfs) = 전위순회(VLR) / 스택 활용
2) 너비 우선 탐색(bfs) = 레벨순회 / 큐 활용

인접 행렬 시간복잡도 : O(N^2)
인접 리스트 시간복잡도 : O(n+e) (정점의 수 + 간선의 수)
간선의 수가 적을 때 : 인접 리스트 사용하는 것이 좋음
간선의 수가 많을 때 : 인접 행렬과 인접 리스트 둘 중 어는것 사용해도 상관없음
